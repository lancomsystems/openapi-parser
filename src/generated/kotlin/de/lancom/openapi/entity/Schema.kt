/*****************************************************************************
**   C A U T I O N                                                          **
**   This file is auto-generated!                                           **
**   If you want to make changes, please see the README.md file.            **
**   Please do not edit this file directly!                                 **
*****************************************************************************/
package de.lancom.openapi.entity

import com.fasterxml.jackson.databind.annotation.JsonDeserialize
import com.fasterxml.jackson.databind.annotation.JsonSerialize
import de.lancom.openapi.field.Field
import de.lancom.openapi.jackson.EntityDeserializer
import de.lancom.openapi.jackson.EntitySerializer
import de.lancom.openapi.jackson.ReferenceParser
import de.lancom.openapi.jackson.Wrapper
import de.lancom.openapi.refs.Instance
import de.lancom.openapi.refs.ReferenceOrInstance
import de.lancom.openapi.refs.Referenceable
import de.lancom.openapi.tools.toYamlString

// hint:9A1BF04C
@Suppress("PropertyName")
@JsonSerialize(using = Schema.Companion.Serializer::class)
@JsonDeserialize(using = Schema.Companion.Deserializer::class)
data class Schema(
    val _title: Field<String?> = Field.unset(),
    val _multipleOf: Field<Int?> = Field.unset(),
    val _maximum: Field<Int?> = Field.unset(),
    val _exclusiveMaximum: Field<Boolean> = Field.unset(),
    val _minimum: Field<Int?> = Field.unset(),
    val _exclusiveMinimum: Field<Boolean> = Field.unset(),
    val _maxLength: Field<Int?> = Field.unset(),
    val _minLength: Field<Int> = Field.unset(),
    val _pattern: Field<String?> = Field.unset(),
    val _maxItems: Field<Int?> = Field.unset(),
    val _minItems: Field<Int> = Field.unset(),
    val _uniqueItems: Field<Boolean> = Field.unset(),
    val _maxProperties: Field<Int?> = Field.unset(),
    val _minProperties: Field<Int> = Field.unset(),
    val _required: Field<Set<String?>?> = Field.unset(),
    val _enum: Field<Set<String?>?> = Field.unset(),
    val _type: Field<SchemaType?> = Field.unset(),
    val _not: Field<ReferenceOrInstance<Schema>?> = Field.unset(),
    val _allOf: Field<List<ReferenceOrInstance<Schema>?>?> = Field.unset(),
    val _oneOf: Field<List<ReferenceOrInstance<Schema>?>?> = Field.unset(),
    val _anyOf: Field<List<ReferenceOrInstance<Schema>?>?> = Field.unset(),
    val _items: Field<ReferenceOrInstance<Schema>?> = Field.unset(),
    val _properties: Field<Map<String, ReferenceOrInstance<Schema>?>?> = Field.unset(),
    val _additionalProperties: Field<AdditionalProperties> = Field.unset(),
    val _description: Field<String?> = Field.unset(),
    val _format: Field<String?> = Field.unset(),
    val _default: Field<DefaultJson?> = Field.unset(),
    val _nullable: Field<Boolean> = Field.unset(),
    val _discriminator: Field<Discriminator?> = Field.unset(),
    val _readOnly: Field<Boolean> = Field.unset(),
    val _writeOnly: Field<Boolean> = Field.unset(),
    val _example: Field<ExampleJson?> = Field.unset(),
    val _externalDocs: Field<ExternalDocumentation?> = Field.unset(),
    val _deprecated: Field<Boolean> = Field.unset(),
    val _xml: Field<XML?> = Field.unset(),
    val _extensions: Field<Map<String, Extension?>> = Field.unset(),
) : Referenceable {

    ///////////////////////
    //
    // title
    //
    ///////////////////////

    // hint:3A7F9B2E
    val title: String?
        get() = _title.orNull

    // hint:F0C48D71
    fun setTitleField(title: Field<String?>): Schema {
        return copy(_title = title)
    }

    // hint:8E56A4D9
    fun updateTitleField(updater: (Field<String?>) -> Field<String?>): Schema {
        return setTitleField(updater(_title))
    }

    // hint:B1D730FC
    fun updateTitle(updater: (String?) -> String?): Schema {
        return updateTitleField { field ->
            field.flatMap { value ->
                Field(updater(value))
            }
        }
    }

    // hint:6542E98A
    fun mergeTitleField(titleFieldToMerge: Field<String?>): Schema {
        return mergeTitle(titleFieldToMerge.orNull)
    }

    // hint:A8BC6F23
    fun mergeTitle(titleToMerge: String?): Schema {
        return if (titleToMerge == null) {
            this
        } else {
            val oldTitle = _title.orNull
            if (oldTitle == null) {
                setTitleField(Field(titleToMerge))
            } else {
                // hint:2F684DAC
                setTitle(titleToMerge)
            }
        }
    }

    // hint:87B3E19C
    fun setTitle(title: String?): Schema {
        return setTitleField(Field(title))
    }

    // hint:D465F782
    fun unsetTitle(): Schema {
        return setTitleField(Field.unset())
    }

    // hint:47C9A0F6
    fun addTitle(title: String): Schema {
        if (this.title != null) {
            throw IllegalStateException("Field title of Entity Schema is already set to '${this.title}', refused to add new value '$title'")
        }
        return setTitle(title)
    }

    ///////////////////////
    //
    // multipleOf
    //
    ///////////////////////

    // hint:3A7F9B2E
    val multipleOf: Int?
        get() = _multipleOf.orNull

    // hint:F0C48D71
    fun setMultipleOfField(multipleOf: Field<Int?>): Schema {
        return copy(_multipleOf = multipleOf)
    }

    // hint:8E56A4D9
    fun updateMultipleOfField(updater: (Field<Int?>) -> Field<Int?>): Schema {
        return setMultipleOfField(updater(_multipleOf))
    }

    // hint:B1D730FC
    fun updateMultipleOf(updater: (Int?) -> Int?): Schema {
        return updateMultipleOfField { field ->
            field.flatMap { value ->
                Field(updater(value))
            }
        }
    }

    // hint:6542E98A
    fun mergeMultipleOfField(multipleOfFieldToMerge: Field<Int?>): Schema {
        return mergeMultipleOf(multipleOfFieldToMerge.orNull)
    }

    // hint:A8BC6F23
    fun mergeMultipleOf(multipleOfToMerge: Int?): Schema {
        return if (multipleOfToMerge == null) {
            this
        } else {
            val oldMultipleOf = _multipleOf.orNull
            if (oldMultipleOf == null) {
                setMultipleOfField(Field(multipleOfToMerge))
            } else {
                // hint:2F684DAC
                setMultipleOf(multipleOfToMerge)
            }
        }
    }

    // hint:87B3E19C
    fun setMultipleOf(multipleOf: Int?): Schema {
        return setMultipleOfField(Field(multipleOf))
    }

    // hint:D465F782
    fun unsetMultipleOf(): Schema {
        return setMultipleOfField(Field.unset())
    }

    // hint:47C9A0F6
    fun addMultipleOf(multipleOf: Int): Schema {
        if (this.multipleOf != null) {
            throw IllegalStateException("Field multipleOf of Entity Schema is already set to '${this.multipleOf}', refused to add new value '$multipleOf'")
        }
        return setMultipleOf(multipleOf)
    }

    ///////////////////////
    //
    // maximum
    //
    ///////////////////////

    // hint:3A7F9B2E
    val maximum: Int?
        get() = _maximum.orNull

    // hint:F0C48D71
    fun setMaximumField(maximum: Field<Int?>): Schema {
        return copy(_maximum = maximum)
    }

    // hint:8E56A4D9
    fun updateMaximumField(updater: (Field<Int?>) -> Field<Int?>): Schema {
        return setMaximumField(updater(_maximum))
    }

    // hint:B1D730FC
    fun updateMaximum(updater: (Int?) -> Int?): Schema {
        return updateMaximumField { field ->
            field.flatMap { value ->
                Field(updater(value))
            }
        }
    }

    // hint:6542E98A
    fun mergeMaximumField(maximumFieldToMerge: Field<Int?>): Schema {
        return mergeMaximum(maximumFieldToMerge.orNull)
    }

    // hint:A8BC6F23
    fun mergeMaximum(maximumToMerge: Int?): Schema {
        return if (maximumToMerge == null) {
            this
        } else {
            val oldMaximum = _maximum.orNull
            if (oldMaximum == null) {
                setMaximumField(Field(maximumToMerge))
            } else {
                // hint:2F684DAC
                setMaximum(maximumToMerge)
            }
        }
    }

    // hint:87B3E19C
    fun setMaximum(maximum: Int?): Schema {
        return setMaximumField(Field(maximum))
    }

    // hint:D465F782
    fun unsetMaximum(): Schema {
        return setMaximumField(Field.unset())
    }

    // hint:47C9A0F6
    fun addMaximum(maximum: Int): Schema {
        if (this.maximum != null) {
            throw IllegalStateException("Field maximum of Entity Schema is already set to '${this.maximum}', refused to add new value '$maximum'")
        }
        return setMaximum(maximum)
    }

    ///////////////////////
    //
    // exclusiveMaximum
    //
    ///////////////////////

    // hint:3A7F9B2E
    val exclusiveMaximum: Boolean
        get() = _exclusiveMaximum.orNull ?: false

    // hint:F0C48D71
    fun setExclusiveMaximumField(exclusiveMaximum: Field<Boolean>): Schema {
        return copy(_exclusiveMaximum = exclusiveMaximum)
    }

    // hint:8E56A4D9
    fun updateExclusiveMaximumField(updater: (Field<Boolean>) -> Field<Boolean>): Schema {
        return setExclusiveMaximumField(updater(_exclusiveMaximum))
    }

    // hint:B1D730FC
    fun updateExclusiveMaximum(updater: (Boolean) -> Boolean): Schema {
        return updateExclusiveMaximumField { field ->
            field.flatMap { value ->
                Field(updater(value))
            }
        }
    }

    // hint:6542E98A
    fun mergeExclusiveMaximumField(exclusiveMaximumFieldToMerge: Field<Boolean>): Schema {
        return mergeExclusiveMaximum(exclusiveMaximumFieldToMerge.orNull)
    }

    // hint:A8BC6F23
    fun mergeExclusiveMaximum(exclusiveMaximumToMerge: Boolean?): Schema {
        return if (exclusiveMaximumToMerge == null) {
            this
        } else {
            val oldExclusiveMaximum = _exclusiveMaximum.orNull
            if (oldExclusiveMaximum == null) {
                setExclusiveMaximumField(Field(exclusiveMaximumToMerge))
            } else {
                // hint:2F684DAC
                setExclusiveMaximum(exclusiveMaximumToMerge)
            }
        }
    }

    // hint:87B3E19C
    fun setExclusiveMaximum(exclusiveMaximum: Boolean): Schema {
        return setExclusiveMaximumField(Field(exclusiveMaximum))
    }

    // hint:D465F782
    fun unsetExclusiveMaximum(): Schema {
        return setExclusiveMaximumField(Field.unset())
    }

    // hint:47C9A0F6
    fun addExclusiveMaximum(exclusiveMaximum: Boolean = true): Schema {
        return setExclusiveMaximum(exclusiveMaximum)
    }

    ///////////////////////
    //
    // minimum
    //
    ///////////////////////

    // hint:3A7F9B2E
    val minimum: Int?
        get() = _minimum.orNull

    // hint:F0C48D71
    fun setMinimumField(minimum: Field<Int?>): Schema {
        return copy(_minimum = minimum)
    }

    // hint:8E56A4D9
    fun updateMinimumField(updater: (Field<Int?>) -> Field<Int?>): Schema {
        return setMinimumField(updater(_minimum))
    }

    // hint:B1D730FC
    fun updateMinimum(updater: (Int?) -> Int?): Schema {
        return updateMinimumField { field ->
            field.flatMap { value ->
                Field(updater(value))
            }
        }
    }

    // hint:6542E98A
    fun mergeMinimumField(minimumFieldToMerge: Field<Int?>): Schema {
        return mergeMinimum(minimumFieldToMerge.orNull)
    }

    // hint:A8BC6F23
    fun mergeMinimum(minimumToMerge: Int?): Schema {
        return if (minimumToMerge == null) {
            this
        } else {
            val oldMinimum = _minimum.orNull
            if (oldMinimum == null) {
                setMinimumField(Field(minimumToMerge))
            } else {
                // hint:2F684DAC
                setMinimum(minimumToMerge)
            }
        }
    }

    // hint:87B3E19C
    fun setMinimum(minimum: Int?): Schema {
        return setMinimumField(Field(minimum))
    }

    // hint:D465F782
    fun unsetMinimum(): Schema {
        return setMinimumField(Field.unset())
    }

    // hint:47C9A0F6
    fun addMinimum(minimum: Int): Schema {
        if (this.minimum != null) {
            throw IllegalStateException("Field minimum of Entity Schema is already set to '${this.minimum}', refused to add new value '$minimum'")
        }
        return setMinimum(minimum)
    }

    ///////////////////////
    //
    // exclusiveMinimum
    //
    ///////////////////////

    // hint:3A7F9B2E
    val exclusiveMinimum: Boolean
        get() = _exclusiveMinimum.orNull ?: false

    // hint:F0C48D71
    fun setExclusiveMinimumField(exclusiveMinimum: Field<Boolean>): Schema {
        return copy(_exclusiveMinimum = exclusiveMinimum)
    }

    // hint:8E56A4D9
    fun updateExclusiveMinimumField(updater: (Field<Boolean>) -> Field<Boolean>): Schema {
        return setExclusiveMinimumField(updater(_exclusiveMinimum))
    }

    // hint:B1D730FC
    fun updateExclusiveMinimum(updater: (Boolean) -> Boolean): Schema {
        return updateExclusiveMinimumField { field ->
            field.flatMap { value ->
                Field(updater(value))
            }
        }
    }

    // hint:6542E98A
    fun mergeExclusiveMinimumField(exclusiveMinimumFieldToMerge: Field<Boolean>): Schema {
        return mergeExclusiveMinimum(exclusiveMinimumFieldToMerge.orNull)
    }

    // hint:A8BC6F23
    fun mergeExclusiveMinimum(exclusiveMinimumToMerge: Boolean?): Schema {
        return if (exclusiveMinimumToMerge == null) {
            this
        } else {
            val oldExclusiveMinimum = _exclusiveMinimum.orNull
            if (oldExclusiveMinimum == null) {
                setExclusiveMinimumField(Field(exclusiveMinimumToMerge))
            } else {
                // hint:2F684DAC
                setExclusiveMinimum(exclusiveMinimumToMerge)
            }
        }
    }

    // hint:87B3E19C
    fun setExclusiveMinimum(exclusiveMinimum: Boolean): Schema {
        return setExclusiveMinimumField(Field(exclusiveMinimum))
    }

    // hint:D465F782
    fun unsetExclusiveMinimum(): Schema {
        return setExclusiveMinimumField(Field.unset())
    }

    // hint:47C9A0F6
    fun addExclusiveMinimum(exclusiveMinimum: Boolean = true): Schema {
        return setExclusiveMinimum(exclusiveMinimum)
    }

    ///////////////////////
    //
    // maxLength
    //
    ///////////////////////

    // hint:3A7F9B2E
    val maxLength: Int?
        get() = _maxLength.orNull

    // hint:F0C48D71
    fun setMaxLengthField(maxLength: Field<Int?>): Schema {
        return copy(_maxLength = maxLength)
    }

    // hint:8E56A4D9
    fun updateMaxLengthField(updater: (Field<Int?>) -> Field<Int?>): Schema {
        return setMaxLengthField(updater(_maxLength))
    }

    // hint:B1D730FC
    fun updateMaxLength(updater: (Int?) -> Int?): Schema {
        return updateMaxLengthField { field ->
            field.flatMap { value ->
                Field(updater(value))
            }
        }
    }

    // hint:6542E98A
    fun mergeMaxLengthField(maxLengthFieldToMerge: Field<Int?>): Schema {
        return mergeMaxLength(maxLengthFieldToMerge.orNull)
    }

    // hint:A8BC6F23
    fun mergeMaxLength(maxLengthToMerge: Int?): Schema {
        return if (maxLengthToMerge == null) {
            this
        } else {
            val oldMaxLength = _maxLength.orNull
            if (oldMaxLength == null) {
                setMaxLengthField(Field(maxLengthToMerge))
            } else {
                // hint:2F684DAC
                setMaxLength(maxLengthToMerge)
            }
        }
    }

    // hint:87B3E19C
    fun setMaxLength(maxLength: Int?): Schema {
        return setMaxLengthField(Field(maxLength))
    }

    // hint:D465F782
    fun unsetMaxLength(): Schema {
        return setMaxLengthField(Field.unset())
    }

    // hint:47C9A0F6
    fun addMaxLength(maxLength: Int): Schema {
        if (this.maxLength != null) {
            throw IllegalStateException("Field maxLength of Entity Schema is already set to '${this.maxLength}', refused to add new value '$maxLength'")
        }
        return setMaxLength(maxLength)
    }

    ///////////////////////
    //
    // minLength
    //
    ///////////////////////

    // hint:3A7F9B2E
    val minLength: Int
        get() = _minLength.orNull ?: 0

    // hint:F0C48D71
    fun setMinLengthField(minLength: Field<Int>): Schema {
        return copy(_minLength = minLength)
    }

    // hint:8E56A4D9
    fun updateMinLengthField(updater: (Field<Int>) -> Field<Int>): Schema {
        return setMinLengthField(updater(_minLength))
    }

    // hint:B1D730FC
    fun updateMinLength(updater: (Int) -> Int): Schema {
        return updateMinLengthField { field ->
            field.flatMap { value ->
                Field(updater(value))
            }
        }
    }

    // hint:6542E98A
    fun mergeMinLengthField(minLengthFieldToMerge: Field<Int>): Schema {
        return mergeMinLength(minLengthFieldToMerge.orNull)
    }

    // hint:A8BC6F23
    fun mergeMinLength(minLengthToMerge: Int?): Schema {
        return if (minLengthToMerge == null) {
            this
        } else {
            val oldMinLength = _minLength.orNull
            if (oldMinLength == null) {
                setMinLengthField(Field(minLengthToMerge))
            } else {
                // hint:2F684DAC
                setMinLength(minLengthToMerge)
            }
        }
    }

    // hint:87B3E19C
    fun setMinLength(minLength: Int): Schema {
        return setMinLengthField(Field(minLength))
    }

    // hint:D465F782
    fun unsetMinLength(): Schema {
        return setMinLengthField(Field.unset())
    }

    // hint:47C9A0F6
    fun addMinLength(minLength: Int): Schema {
        return setMinLength(minLength)
    }

    ///////////////////////
    //
    // pattern
    //
    ///////////////////////

    // hint:3A7F9B2E
    val pattern: String?
        get() = _pattern.orNull

    // hint:F0C48D71
    fun setPatternField(pattern: Field<String?>): Schema {
        return copy(_pattern = pattern)
    }

    // hint:8E56A4D9
    fun updatePatternField(updater: (Field<String?>) -> Field<String?>): Schema {
        return setPatternField(updater(_pattern))
    }

    // hint:B1D730FC
    fun updatePattern(updater: (String?) -> String?): Schema {
        return updatePatternField { field ->
            field.flatMap { value ->
                Field(updater(value))
            }
        }
    }

    // hint:6542E98A
    fun mergePatternField(patternFieldToMerge: Field<String?>): Schema {
        return mergePattern(patternFieldToMerge.orNull)
    }

    // hint:A8BC6F23
    fun mergePattern(patternToMerge: String?): Schema {
        return if (patternToMerge == null) {
            this
        } else {
            val oldPattern = _pattern.orNull
            if (oldPattern == null) {
                setPatternField(Field(patternToMerge))
            } else {
                // hint:2F684DAC
                setPattern(patternToMerge)
            }
        }
    }

    // hint:87B3E19C
    fun setPattern(pattern: String?): Schema {
        return setPatternField(Field(pattern))
    }

    // hint:D465F782
    fun unsetPattern(): Schema {
        return setPatternField(Field.unset())
    }

    // hint:47C9A0F6
    fun addPattern(pattern: String): Schema {
        if (this.pattern != null) {
            throw IllegalStateException("Field pattern of Entity Schema is already set to '${this.pattern}', refused to add new value '$pattern'")
        }
        return setPattern(pattern)
    }

    // hint:4D98C1B6
    @get:com.fasterxml.jackson.annotation.JsonIgnore
    val patternRegex: Regex? by lazy {
        pattern?.toRegex()
    }

    ///////////////////////
    //
    // maxItems
    //
    ///////////////////////

    // hint:3A7F9B2E
    val maxItems: Int?
        get() = _maxItems.orNull

    // hint:F0C48D71
    fun setMaxItemsField(maxItems: Field<Int?>): Schema {
        return copy(_maxItems = maxItems)
    }

    // hint:8E56A4D9
    fun updateMaxItemsField(updater: (Field<Int?>) -> Field<Int?>): Schema {
        return setMaxItemsField(updater(_maxItems))
    }

    // hint:B1D730FC
    fun updateMaxItems(updater: (Int?) -> Int?): Schema {
        return updateMaxItemsField { field ->
            field.flatMap { value ->
                Field(updater(value))
            }
        }
    }

    // hint:6542E98A
    fun mergeMaxItemsField(maxItemsFieldToMerge: Field<Int?>): Schema {
        return mergeMaxItems(maxItemsFieldToMerge.orNull)
    }

    // hint:A8BC6F23
    fun mergeMaxItems(maxItemsToMerge: Int?): Schema {
        return if (maxItemsToMerge == null) {
            this
        } else {
            val oldMaxItems = _maxItems.orNull
            if (oldMaxItems == null) {
                setMaxItemsField(Field(maxItemsToMerge))
            } else {
                // hint:2F684DAC
                setMaxItems(maxItemsToMerge)
            }
        }
    }

    // hint:87B3E19C
    fun setMaxItems(maxItems: Int?): Schema {
        return setMaxItemsField(Field(maxItems))
    }

    // hint:D465F782
    fun unsetMaxItems(): Schema {
        return setMaxItemsField(Field.unset())
    }

    // hint:47C9A0F6
    fun addMaxItems(maxItems: Int): Schema {
        if (this.maxItems != null) {
            throw IllegalStateException("Field maxItems of Entity Schema is already set to '${this.maxItems}', refused to add new value '$maxItems'")
        }
        return setMaxItems(maxItems)
    }

    ///////////////////////
    //
    // minItems
    //
    ///////////////////////

    // hint:3A7F9B2E
    val minItems: Int
        get() = _minItems.orNull ?: 0

    // hint:F0C48D71
    fun setMinItemsField(minItems: Field<Int>): Schema {
        return copy(_minItems = minItems)
    }

    // hint:8E56A4D9
    fun updateMinItemsField(updater: (Field<Int>) -> Field<Int>): Schema {
        return setMinItemsField(updater(_minItems))
    }

    // hint:B1D730FC
    fun updateMinItems(updater: (Int) -> Int): Schema {
        return updateMinItemsField { field ->
            field.flatMap { value ->
                Field(updater(value))
            }
        }
    }

    // hint:6542E98A
    fun mergeMinItemsField(minItemsFieldToMerge: Field<Int>): Schema {
        return mergeMinItems(minItemsFieldToMerge.orNull)
    }

    // hint:A8BC6F23
    fun mergeMinItems(minItemsToMerge: Int?): Schema {
        return if (minItemsToMerge == null) {
            this
        } else {
            val oldMinItems = _minItems.orNull
            if (oldMinItems == null) {
                setMinItemsField(Field(minItemsToMerge))
            } else {
                // hint:2F684DAC
                setMinItems(minItemsToMerge)
            }
        }
    }

    // hint:87B3E19C
    fun setMinItems(minItems: Int): Schema {
        return setMinItemsField(Field(minItems))
    }

    // hint:D465F782
    fun unsetMinItems(): Schema {
        return setMinItemsField(Field.unset())
    }

    // hint:47C9A0F6
    fun addMinItems(minItems: Int): Schema {
        return setMinItems(minItems)
    }

    ///////////////////////
    //
    // uniqueItems
    //
    ///////////////////////

    // hint:3A7F9B2E
    val uniqueItems: Boolean
        get() = _uniqueItems.orNull ?: false

    // hint:F0C48D71
    fun setUniqueItemsField(uniqueItems: Field<Boolean>): Schema {
        return copy(_uniqueItems = uniqueItems)
    }

    // hint:8E56A4D9
    fun updateUniqueItemsField(updater: (Field<Boolean>) -> Field<Boolean>): Schema {
        return setUniqueItemsField(updater(_uniqueItems))
    }

    // hint:B1D730FC
    fun updateUniqueItems(updater: (Boolean) -> Boolean): Schema {
        return updateUniqueItemsField { field ->
            field.flatMap { value ->
                Field(updater(value))
            }
        }
    }

    // hint:6542E98A
    fun mergeUniqueItemsField(uniqueItemsFieldToMerge: Field<Boolean>): Schema {
        return mergeUniqueItems(uniqueItemsFieldToMerge.orNull)
    }

    // hint:A8BC6F23
    fun mergeUniqueItems(uniqueItemsToMerge: Boolean?): Schema {
        return if (uniqueItemsToMerge == null) {
            this
        } else {
            val oldUniqueItems = _uniqueItems.orNull
            if (oldUniqueItems == null) {
                setUniqueItemsField(Field(uniqueItemsToMerge))
            } else {
                // hint:2F684DAC
                setUniqueItems(uniqueItemsToMerge)
            }
        }
    }

    // hint:87B3E19C
    fun setUniqueItems(uniqueItems: Boolean): Schema {
        return setUniqueItemsField(Field(uniqueItems))
    }

    // hint:D465F782
    fun unsetUniqueItems(): Schema {
        return setUniqueItemsField(Field.unset())
    }

    // hint:47C9A0F6
    fun addUniqueItems(uniqueItems: Boolean = true): Schema {
        return setUniqueItems(uniqueItems)
    }

    ///////////////////////
    //
    // maxProperties
    //
    ///////////////////////

    // hint:3A7F9B2E
    val maxProperties: Int?
        get() = _maxProperties.orNull

    // hint:F0C48D71
    fun setMaxPropertiesField(maxProperties: Field<Int?>): Schema {
        return copy(_maxProperties = maxProperties)
    }

    // hint:8E56A4D9
    fun updateMaxPropertiesField(updater: (Field<Int?>) -> Field<Int?>): Schema {
        return setMaxPropertiesField(updater(_maxProperties))
    }

    // hint:B1D730FC
    fun updateMaxProperties(updater: (Int?) -> Int?): Schema {
        return updateMaxPropertiesField { field ->
            field.flatMap { value ->
                Field(updater(value))
            }
        }
    }

    // hint:6542E98A
    fun mergeMaxPropertiesField(maxPropertiesFieldToMerge: Field<Int?>): Schema {
        return mergeMaxProperties(maxPropertiesFieldToMerge.orNull)
    }

    // hint:A8BC6F23
    fun mergeMaxProperties(maxPropertiesToMerge: Int?): Schema {
        return if (maxPropertiesToMerge == null) {
            this
        } else {
            val oldMaxProperties = _maxProperties.orNull
            if (oldMaxProperties == null) {
                setMaxPropertiesField(Field(maxPropertiesToMerge))
            } else {
                // hint:2F684DAC
                setMaxProperties(maxPropertiesToMerge)
            }
        }
    }

    // hint:87B3E19C
    fun setMaxProperties(maxProperties: Int?): Schema {
        return setMaxPropertiesField(Field(maxProperties))
    }

    // hint:D465F782
    fun unsetMaxProperties(): Schema {
        return setMaxPropertiesField(Field.unset())
    }

    // hint:47C9A0F6
    fun addMaxProperties(maxProperties: Int): Schema {
        if (this.maxProperties != null) {
            throw IllegalStateException("Field maxProperties of Entity Schema is already set to '${this.maxProperties}', refused to add new value '$maxProperties'")
        }
        return setMaxProperties(maxProperties)
    }

    ///////////////////////
    //
    // minProperties
    //
    ///////////////////////

    // hint:3A7F9B2E
    val minProperties: Int
        get() = _minProperties.orNull ?: 0

    // hint:F0C48D71
    fun setMinPropertiesField(minProperties: Field<Int>): Schema {
        return copy(_minProperties = minProperties)
    }

    // hint:8E56A4D9
    fun updateMinPropertiesField(updater: (Field<Int>) -> Field<Int>): Schema {
        return setMinPropertiesField(updater(_minProperties))
    }

    // hint:B1D730FC
    fun updateMinProperties(updater: (Int) -> Int): Schema {
        return updateMinPropertiesField { field ->
            field.flatMap { value ->
                Field(updater(value))
            }
        }
    }

    // hint:6542E98A
    fun mergeMinPropertiesField(minPropertiesFieldToMerge: Field<Int>): Schema {
        return mergeMinProperties(minPropertiesFieldToMerge.orNull)
    }

    // hint:A8BC6F23
    fun mergeMinProperties(minPropertiesToMerge: Int?): Schema {
        return if (minPropertiesToMerge == null) {
            this
        } else {
            val oldMinProperties = _minProperties.orNull
            if (oldMinProperties == null) {
                setMinPropertiesField(Field(minPropertiesToMerge))
            } else {
                // hint:2F684DAC
                setMinProperties(minPropertiesToMerge)
            }
        }
    }

    // hint:87B3E19C
    fun setMinProperties(minProperties: Int): Schema {
        return setMinPropertiesField(Field(minProperties))
    }

    // hint:D465F782
    fun unsetMinProperties(): Schema {
        return setMinPropertiesField(Field.unset())
    }

    // hint:47C9A0F6
    fun addMinProperties(minProperties: Int): Schema {
        return setMinProperties(minProperties)
    }

    ///////////////////////
    //
    // required
    //
    ///////////////////////

    // hint:3A7F9B2E
    val required: Set<String?>?
        get() = _required.orNull

    // hint:F0C48D71
    fun setRequiredField(required: Field<Set<String?>?>): Schema {
        return copy(_required = required)
    }

    // hint:8E56A4D9
    fun updateRequiredField(updater: (Field<Set<String?>?>) -> Field<Set<String?>?>): Schema {
        return setRequiredField(updater(_required))
    }

    // hint:B1D730FC
    fun updateRequired(updater: (Set<String?>?) -> Set<String?>?): Schema {
        return updateRequiredField { field ->
            field.flatMap { value ->
                Field(updater(value))
            }
        }
    }

    // hint:6542E98A
    fun mergeRequiredField(requiredFieldToMerge: Field<Set<String?>?>): Schema {
        return mergeRequired(requiredFieldToMerge.orNull)
    }

    // hint:A8BC6F23
    fun mergeRequired(requiredToMerge: Set<String?>?): Schema {
        return if (requiredToMerge == null) {
            this
        } else {
            val oldRequired = _required.orNull
            if (oldRequired == null) {
                setRequiredField(Field(requiredToMerge))
            } else {
                // hint:C2F147E9
                setRequired(oldRequired + requiredToMerge)
            }
        }
    }

    // hint:87B3E19C
    fun setRequired(required: Set<String?>?): Schema {
        return setRequiredField(Field(required))
    }

    // hint:D465F782
    fun unsetRequired(): Schema {
        return setRequiredField(Field.unset())
    }

    // hint:3E9A8C01
    fun addRequired(required: Set<String?>?): Schema {
        return setRequired((this.required ?: emptySet()) + (required ?: emptySet()))
    }

    // hint:F7420EB5
    fun addRequired(vararg required: String): Schema {
        return addRequired(required.toSet())
    }

    ///////////////////////
    //
    // enum
    //
    ///////////////////////

    // hint:3A7F9B2E
    val enum: Set<String?>?
        get() = _enum.orNull

    // hint:F0C48D71
    fun setEnumField(enum: Field<Set<String?>?>): Schema {
        return copy(_enum = enum)
    }

    // hint:8E56A4D9
    fun updateEnumField(updater: (Field<Set<String?>?>) -> Field<Set<String?>?>): Schema {
        return setEnumField(updater(_enum))
    }

    // hint:B1D730FC
    fun updateEnum(updater: (Set<String?>?) -> Set<String?>?): Schema {
        return updateEnumField { field ->
            field.flatMap { value ->
                Field(updater(value))
            }
        }
    }

    // hint:6542E98A
    fun mergeEnumField(enumFieldToMerge: Field<Set<String?>?>): Schema {
        return mergeEnum(enumFieldToMerge.orNull)
    }

    // hint:A8BC6F23
    fun mergeEnum(enumToMerge: Set<String?>?): Schema {
        return if (enumToMerge == null) {
            this
        } else {
            val oldEnum = _enum.orNull
            if (oldEnum == null) {
                setEnumField(Field(enumToMerge))
            } else {
                // hint:C2F147E9
                setEnum(oldEnum + enumToMerge)
            }
        }
    }

    // hint:87B3E19C
    fun setEnum(enum: Set<String?>?): Schema {
        return setEnumField(Field(enum))
    }

    // hint:D465F782
    fun unsetEnum(): Schema {
        return setEnumField(Field.unset())
    }

    // hint:3E9A8C01
    fun addEnum(enum: Set<String?>?): Schema {
        return setEnum((this.enum ?: emptySet()) + (enum ?: emptySet()))
    }

    // hint:F7420EB5
    fun addEnum(vararg enum: String): Schema {
        return addEnum(enum.toSet())
    }

    ///////////////////////
    //
    // type
    //
    ///////////////////////

    // hint:3A7F9B2E
    val type: SchemaType?
        get() = _type.orNull

    // hint:F0C48D71
    fun setTypeField(type: Field<SchemaType?>): Schema {
        return copy(_type = type)
    }

    // hint:8E56A4D9
    fun updateTypeField(updater: (Field<SchemaType?>) -> Field<SchemaType?>): Schema {
        return setTypeField(updater(_type))
    }

    // hint:B1D730FC
    fun updateType(updater: (SchemaType?) -> SchemaType?): Schema {
        return updateTypeField { field ->
            field.flatMap { value ->
                Field(updater(value))
            }
        }
    }

    // hint:6542E98A
    fun mergeTypeField(typeFieldToMerge: Field<SchemaType?>): Schema {
        return mergeType(typeFieldToMerge.orNull)
    }

    // hint:A8BC6F23
    fun mergeType(typeToMerge: SchemaType?): Schema {
        return if (typeToMerge == null) {
            this
        } else {
            val oldType = _type.orNull
            if (oldType == null) {
                setTypeField(Field(typeToMerge))
            } else {
                // hint:2F684DAC
                setType(typeToMerge)
            }
        }
    }

    // hint:87B3E19C
    fun setType(type: SchemaType?): Schema {
        return setTypeField(Field(type))
    }

    // hint:D465F782
    fun unsetType(): Schema {
        return setTypeField(Field.unset())
    }

    // hint:47C9A0F6
    fun addType(type: SchemaType): Schema {
        if (this.type != null) {
            throw IllegalStateException("Field type of Entity Schema is already set to '${this.type}', refused to add new value '$type'")
        }
        return setType(type)
    }

    // hint:E3AF607D
    fun setTypeArray(): Schema {
        return setType(SchemaType.array)
    }

    // hint:3D98E6A5
    fun addTypeArray(): Schema {
        return addType(SchemaType.array)
    }

    // hint:E3AF607D
    fun setTypeBoolean(): Schema {
        return setType(SchemaType.boolean)
    }

    // hint:3D98E6A5
    fun addTypeBoolean(): Schema {
        return addType(SchemaType.boolean)
    }

    // hint:E3AF607D
    fun setTypeInteger(): Schema {
        return setType(SchemaType.integer)
    }

    // hint:3D98E6A5
    fun addTypeInteger(): Schema {
        return addType(SchemaType.integer)
    }

    // hint:E3AF607D
    fun setTypeNumber(): Schema {
        return setType(SchemaType.number)
    }

    // hint:3D98E6A5
    fun addTypeNumber(): Schema {
        return addType(SchemaType.number)
    }

    // hint:E3AF607D
    fun setTypeObject(): Schema {
        return setType(SchemaType.`object`)
    }

    // hint:3D98E6A5
    fun addTypeObject(): Schema {
        return addType(SchemaType.`object`)
    }

    // hint:E3AF607D
    fun setTypeString(): Schema {
        return setType(SchemaType.string)
    }

    // hint:3D98E6A5
    fun addTypeString(): Schema {
        return addType(SchemaType.string)
    }

    ///////////////////////
    //
    // not
    //
    ///////////////////////

    // hint:3A7F9B2E
    val not: ReferenceOrInstance<Schema>?
        get() = _not.orNull

    // hint:F0C48D71
    fun setNotField(not: Field<ReferenceOrInstance<Schema>?>): Schema {
        return copy(_not = not)
    }

    // hint:8E56A4D9
    fun updateNotField(updater: (Field<ReferenceOrInstance<Schema>?>) -> Field<ReferenceOrInstance<Schema>?>): Schema {
        return setNotField(updater(_not))
    }

    // hint:B1D730FC
    fun updateNot(updater: (ReferenceOrInstance<Schema>?) -> ReferenceOrInstance<Schema>?): Schema {
        return updateNotField { field ->
            field.flatMap { value ->
                Field(updater(value))
            }
        }
    }

    // hint:6542E98A
    fun mergeNotField(notFieldToMerge: Field<ReferenceOrInstance<Schema>?>): Schema {
        return mergeNot(notFieldToMerge.orNull)
    }

    // hint:A8BC6F23
    fun mergeNot(notToMerge: ReferenceOrInstance<Schema>?): Schema {
        return if (notToMerge == null) {
            this
        } else {
            val oldNot = _not.orNull
            if (oldNot == null) {
                setNotField(Field(notToMerge))
            } else {
                // hint:2F684DAC
                setNot(notToMerge)
            }
        }
    }

    // hint:87B3E19C
    fun setNot(not: ReferenceOrInstance<Schema>?): Schema {
        return setNotField(Field(not))
    }

    // hint:D465F782
    fun unsetNot(): Schema {
        return setNotField(Field.unset())
    }

    // hint:F8E61D9B
    fun addNot(not: Schema): Schema {
        return addNot(Instance(not))
    }

    // hint:47C9A0F6
    fun addNot(not: ReferenceOrInstance<Schema>): Schema {
        if (this.not != null) {
            throw IllegalStateException("Field not of Entity Schema is already set to '${this.not}', refused to add new value '$not'")
        }
        return setNot(not)
    }

    ///////////////////////
    //
    // allOf
    //
    ///////////////////////

    // hint:3A7F9B2E
    val allOf: List<ReferenceOrInstance<Schema>?>?
        get() = _allOf.orNull

    // hint:F0C48D71
    fun setAllOfField(allOf: Field<List<ReferenceOrInstance<Schema>?>?>): Schema {
        return copy(_allOf = allOf)
    }

    // hint:8E56A4D9
    fun updateAllOfField(updater: (Field<List<ReferenceOrInstance<Schema>?>?>) -> Field<List<ReferenceOrInstance<Schema>?>?>): Schema {
        return setAllOfField(updater(_allOf))
    }

    // hint:B1D730FC
    fun updateAllOf(updater: (List<ReferenceOrInstance<Schema>?>?) -> List<ReferenceOrInstance<Schema>?>?): Schema {
        return updateAllOfField { field ->
            field.flatMap { value ->
                Field(updater(value))
            }
        }
    }

    // hint:6542E98A
    fun mergeAllOfField(allOfFieldToMerge: Field<List<ReferenceOrInstance<Schema>?>?>): Schema {
        return mergeAllOf(allOfFieldToMerge.orNull)
    }

    // hint:A8BC6F23
    fun mergeAllOf(allOfToMerge: List<ReferenceOrInstance<Schema>?>?): Schema {
        return if (allOfToMerge == null) {
            this
        } else {
            val oldAllOf = _allOf.orNull
            if (oldAllOf == null) {
                setAllOfField(Field(allOfToMerge))
            } else {
                // hint:19DE5C87
                setAllOf((oldAllOf + allOfToMerge).distinct())
            }
        }
    }

    // hint:87B3E19C
    fun setAllOf(allOf: List<ReferenceOrInstance<Schema>?>?): Schema {
        return setAllOfField(Field(allOf))
    }

    // hint:D465F782
    fun unsetAllOf(): Schema {
        return setAllOfField(Field.unset())
    }

    // hint:85F37E6D
    @JvmName("addAllOfList")
    fun addAllOf(allOf: List<Schema>): Schema {
        return addAllOf(allOf.map(::Instance).toList())
    }

    // hint:47D2AFC8
    fun addAllOf(vararg allOf: Schema): Schema {
        return addAllOf(allOf.toList())
    }

    // hint:12B6C4A3
    @JvmName("addAllOfArray")
    fun addAllOf(allOf: Array<out Schema>): Schema {
        return addAllOf(allOf.toList())
    }

    // hint:3E9A8C01
    fun addAllOf(allOf: List<ReferenceOrInstance<Schema>?>?): Schema {
        return setAllOf((this.allOf ?: emptyList()) + (allOf ?: emptyList()))
    }

    // hint:F7420EB5
    fun addAllOf(vararg allOf: ReferenceOrInstance<Schema>): Schema {
        return addAllOf(allOf.toList())
    }

    ///////////////////////
    //
    // oneOf
    //
    ///////////////////////

    // hint:3A7F9B2E
    val oneOf: List<ReferenceOrInstance<Schema>?>?
        get() = _oneOf.orNull

    // hint:F0C48D71
    fun setOneOfField(oneOf: Field<List<ReferenceOrInstance<Schema>?>?>): Schema {
        return copy(_oneOf = oneOf)
    }

    // hint:8E56A4D9
    fun updateOneOfField(updater: (Field<List<ReferenceOrInstance<Schema>?>?>) -> Field<List<ReferenceOrInstance<Schema>?>?>): Schema {
        return setOneOfField(updater(_oneOf))
    }

    // hint:B1D730FC
    fun updateOneOf(updater: (List<ReferenceOrInstance<Schema>?>?) -> List<ReferenceOrInstance<Schema>?>?): Schema {
        return updateOneOfField { field ->
            field.flatMap { value ->
                Field(updater(value))
            }
        }
    }

    // hint:6542E98A
    fun mergeOneOfField(oneOfFieldToMerge: Field<List<ReferenceOrInstance<Schema>?>?>): Schema {
        return mergeOneOf(oneOfFieldToMerge.orNull)
    }

    // hint:A8BC6F23
    fun mergeOneOf(oneOfToMerge: List<ReferenceOrInstance<Schema>?>?): Schema {
        return if (oneOfToMerge == null) {
            this
        } else {
            val oldOneOf = _oneOf.orNull
            if (oldOneOf == null) {
                setOneOfField(Field(oneOfToMerge))
            } else {
                // hint:19DE5C87
                setOneOf((oldOneOf + oneOfToMerge).distinct())
            }
        }
    }

    // hint:87B3E19C
    fun setOneOf(oneOf: List<ReferenceOrInstance<Schema>?>?): Schema {
        return setOneOfField(Field(oneOf))
    }

    // hint:D465F782
    fun unsetOneOf(): Schema {
        return setOneOfField(Field.unset())
    }

    // hint:85F37E6D
    @JvmName("addOneOfList")
    fun addOneOf(oneOf: List<Schema>): Schema {
        return addOneOf(oneOf.map(::Instance).toList())
    }

    // hint:47D2AFC8
    fun addOneOf(vararg oneOf: Schema): Schema {
        return addOneOf(oneOf.toList())
    }

    // hint:12B6C4A3
    @JvmName("addOneOfArray")
    fun addOneOf(oneOf: Array<out Schema>): Schema {
        return addOneOf(oneOf.toList())
    }

    // hint:3E9A8C01
    fun addOneOf(oneOf: List<ReferenceOrInstance<Schema>?>?): Schema {
        return setOneOf((this.oneOf ?: emptyList()) + (oneOf ?: emptyList()))
    }

    // hint:F7420EB5
    fun addOneOf(vararg oneOf: ReferenceOrInstance<Schema>): Schema {
        return addOneOf(oneOf.toList())
    }

    ///////////////////////
    //
    // anyOf
    //
    ///////////////////////

    // hint:3A7F9B2E
    val anyOf: List<ReferenceOrInstance<Schema>?>?
        get() = _anyOf.orNull

    // hint:F0C48D71
    fun setAnyOfField(anyOf: Field<List<ReferenceOrInstance<Schema>?>?>): Schema {
        return copy(_anyOf = anyOf)
    }

    // hint:8E56A4D9
    fun updateAnyOfField(updater: (Field<List<ReferenceOrInstance<Schema>?>?>) -> Field<List<ReferenceOrInstance<Schema>?>?>): Schema {
        return setAnyOfField(updater(_anyOf))
    }

    // hint:B1D730FC
    fun updateAnyOf(updater: (List<ReferenceOrInstance<Schema>?>?) -> List<ReferenceOrInstance<Schema>?>?): Schema {
        return updateAnyOfField { field ->
            field.flatMap { value ->
                Field(updater(value))
            }
        }
    }

    // hint:6542E98A
    fun mergeAnyOfField(anyOfFieldToMerge: Field<List<ReferenceOrInstance<Schema>?>?>): Schema {
        return mergeAnyOf(anyOfFieldToMerge.orNull)
    }

    // hint:A8BC6F23
    fun mergeAnyOf(anyOfToMerge: List<ReferenceOrInstance<Schema>?>?): Schema {
        return if (anyOfToMerge == null) {
            this
        } else {
            val oldAnyOf = _anyOf.orNull
            if (oldAnyOf == null) {
                setAnyOfField(Field(anyOfToMerge))
            } else {
                // hint:19DE5C87
                setAnyOf((oldAnyOf + anyOfToMerge).distinct())
            }
        }
    }

    // hint:87B3E19C
    fun setAnyOf(anyOf: List<ReferenceOrInstance<Schema>?>?): Schema {
        return setAnyOfField(Field(anyOf))
    }

    // hint:D465F782
    fun unsetAnyOf(): Schema {
        return setAnyOfField(Field.unset())
    }

    // hint:85F37E6D
    @JvmName("addAnyOfList")
    fun addAnyOf(anyOf: List<Schema>): Schema {
        return addAnyOf(anyOf.map(::Instance).toList())
    }

    // hint:47D2AFC8
    fun addAnyOf(vararg anyOf: Schema): Schema {
        return addAnyOf(anyOf.toList())
    }

    // hint:12B6C4A3
    @JvmName("addAnyOfArray")
    fun addAnyOf(anyOf: Array<out Schema>): Schema {
        return addAnyOf(anyOf.toList())
    }

    // hint:3E9A8C01
    fun addAnyOf(anyOf: List<ReferenceOrInstance<Schema>?>?): Schema {
        return setAnyOf((this.anyOf ?: emptyList()) + (anyOf ?: emptyList()))
    }

    // hint:F7420EB5
    fun addAnyOf(vararg anyOf: ReferenceOrInstance<Schema>): Schema {
        return addAnyOf(anyOf.toList())
    }

    ///////////////////////
    //
    // items
    //
    ///////////////////////

    // hint:3A7F9B2E
    val items: ReferenceOrInstance<Schema>?
        get() = _items.orNull

    // hint:F0C48D71
    fun setItemsField(items: Field<ReferenceOrInstance<Schema>?>): Schema {
        return copy(_items = items)
    }

    // hint:8E56A4D9
    fun updateItemsField(updater: (Field<ReferenceOrInstance<Schema>?>) -> Field<ReferenceOrInstance<Schema>?>): Schema {
        return setItemsField(updater(_items))
    }

    // hint:B1D730FC
    fun updateItems(updater: (ReferenceOrInstance<Schema>?) -> ReferenceOrInstance<Schema>?): Schema {
        return updateItemsField { field ->
            field.flatMap { value ->
                Field(updater(value))
            }
        }
    }

    // hint:6542E98A
    fun mergeItemsField(itemsFieldToMerge: Field<ReferenceOrInstance<Schema>?>): Schema {
        return mergeItems(itemsFieldToMerge.orNull)
    }

    // hint:A8BC6F23
    fun mergeItems(itemsToMerge: ReferenceOrInstance<Schema>?): Schema {
        return if (itemsToMerge == null) {
            this
        } else {
            val oldItems = _items.orNull
            if (oldItems == null) {
                setItemsField(Field(itemsToMerge))
            } else {
                // hint:2F684DAC
                setItems(itemsToMerge)
            }
        }
    }

    // hint:87B3E19C
    fun setItems(items: ReferenceOrInstance<Schema>?): Schema {
        return setItemsField(Field(items))
    }

    // hint:D465F782
    fun unsetItems(): Schema {
        return setItemsField(Field.unset())
    }

    // hint:F8E61D9B
    fun addItems(items: Schema): Schema {
        return addItems(Instance(items))
    }

    // hint:47C9A0F6
    fun addItems(items: ReferenceOrInstance<Schema>): Schema {
        if (this.items != null) {
            throw IllegalStateException("Field items of Entity Schema is already set to '${this.items}', refused to add new value '$items'")
        }
        return setItems(items)
    }

    ///////////////////////
    //
    // properties
    //
    ///////////////////////

    // hint:3A7F9B2E
    val properties: Map<String, ReferenceOrInstance<Schema>?>?
        get() = _properties.orNull

    // hint:F0C48D71
    fun setPropertiesField(properties: Field<Map<String, ReferenceOrInstance<Schema>?>?>): Schema {
        return copy(_properties = properties)
    }

    // hint:8E56A4D9
    fun updatePropertiesField(updater: (Field<Map<String, ReferenceOrInstance<Schema>?>?>) -> Field<Map<String, ReferenceOrInstance<Schema>?>?>): Schema {
        return setPropertiesField(updater(_properties))
    }

    // hint:B1D730FC
    fun updateProperties(updater: (Map<String, ReferenceOrInstance<Schema>?>?) -> Map<String, ReferenceOrInstance<Schema>?>?): Schema {
        return updatePropertiesField { field ->
            field.flatMap { value ->
                Field(updater(value))
            }
        }
    }

    // hint:6542E98A
    fun mergePropertiesField(propertiesFieldToMerge: Field<Map<String, ReferenceOrInstance<Schema>?>?>): Schema {
        return mergeProperties(propertiesFieldToMerge.orNull)
    }

    // hint:A8BC6F23
    fun mergeProperties(propertiesToMerge: Map<String, ReferenceOrInstance<Schema>?>?): Schema {
        return if (propertiesToMerge == null) {
            this
        } else {
            val oldProperties = _properties.orNull
            if (oldProperties == null) {
                setPropertiesField(Field(propertiesToMerge))
            } else {
                // hint:70A3D8B6
                setProperties(de.lancom.openapi.tools.mergeMap(oldProperties, propertiesToMerge))
            }
        }
    }

    // hint:87B3E19C
    fun setProperties(properties: Map<String, ReferenceOrInstance<Schema>?>?): Schema {
        return setPropertiesField(Field(properties))
    }

    // hint:D465F782
    fun unsetProperties(): Schema {
        return setPropertiesField(Field.unset())
    }

    // hint:5C81D396
    fun addProperties(properties: Map<String, ReferenceOrInstance<Schema>?>?): Schema {
        return mergeProperties(properties)
    }

    // hint:1A6B37F8
    fun addProperties(vararg properties: Pair<String, ReferenceOrInstance<Schema>?>): Schema {
        return addProperties(properties.toMap())
    }

    // hint:9D0E4CA5
    fun addProperty(key: String, value: ReferenceOrInstance<Schema>?): Schema {
        return addProperties(key to value)
    }

    // hint:B8F25E73
    fun addProperty(pair: Pair<String, ReferenceOrInstance<Schema>?>): Schema {
        return addProperties(mapOf(pair))
    }

    // hint: 4F7A83E9
    fun addProperty(key: String, value: Schema): Schema {
        return addProperties(key to Instance(value))
    }

    ///////////////////////
    //
    // additionalProperties
    //
    ///////////////////////

    // hint:3A7F9B2E
    val additionalProperties: AdditionalProperties
        get() = _additionalProperties.orNull ?: AdditionalPropertiesBoolean

    // hint:F0C48D71
    fun setAdditionalPropertiesField(additionalProperties: Field<AdditionalProperties>): Schema {
        return copy(_additionalProperties = additionalProperties)
    }

    // hint:8E56A4D9
    fun updateAdditionalPropertiesField(updater: (Field<AdditionalProperties>) -> Field<AdditionalProperties>): Schema {
        return setAdditionalPropertiesField(updater(_additionalProperties))
    }

    // hint:B1D730FC
    fun updateAdditionalProperties(updater: (AdditionalProperties) -> AdditionalProperties): Schema {
        return updateAdditionalPropertiesField { field ->
            field.flatMap { value ->
                Field(updater(value))
            }
        }
    }

    // hint:6542E98A
    fun mergeAdditionalPropertiesField(additionalPropertiesFieldToMerge: Field<AdditionalProperties>): Schema {
        return mergeAdditionalProperties(additionalPropertiesFieldToMerge.orNull)
    }

    // hint:A8BC6F23
    fun mergeAdditionalProperties(additionalPropertiesToMerge: AdditionalProperties?): Schema {
        return if (additionalPropertiesToMerge == null) {
            this
        } else {
            val oldAdditionalProperties = _additionalProperties.orNull
            if (oldAdditionalProperties == null) {
                setAdditionalPropertiesField(Field(additionalPropertiesToMerge))
            } else {
                // hint:E91B4F65
                setAdditionalProperties(oldAdditionalProperties.mergeEntity(additionalPropertiesToMerge))
            }
        }
    }

    // hint:87B3E19C
    fun setAdditionalProperties(additionalProperties: AdditionalProperties): Schema {
        return setAdditionalPropertiesField(Field(additionalProperties))
    }

    // hint:D465F782
    fun unsetAdditionalProperties(): Schema {
        return setAdditionalPropertiesField(Field.unset())
    }

    // hint:47C9A0F6
    fun addAdditionalProperties(additionalProperties: AdditionalProperties): Schema {
        return setAdditionalProperties(additionalProperties)
    }

    ///////////////////////
    //
    // description
    //
    ///////////////////////

    // hint:3A7F9B2E
    val description: String?
        get() = _description.orNull

    // hint:F0C48D71
    fun setDescriptionField(description: Field<String?>): Schema {
        return copy(_description = description)
    }

    // hint:8E56A4D9
    fun updateDescriptionField(updater: (Field<String?>) -> Field<String?>): Schema {
        return setDescriptionField(updater(_description))
    }

    // hint:B1D730FC
    fun updateDescription(updater: (String?) -> String?): Schema {
        return updateDescriptionField { field ->
            field.flatMap { value ->
                Field(updater(value))
            }
        }
    }

    // hint:6542E98A
    fun mergeDescriptionField(descriptionFieldToMerge: Field<String?>): Schema {
        return mergeDescription(descriptionFieldToMerge.orNull)
    }

    // hint:A8BC6F23
    fun mergeDescription(descriptionToMerge: String?): Schema {
        return if (descriptionToMerge == null) {
            this
        } else {
            val oldDescription = _description.orNull
            if (oldDescription == null) {
                setDescriptionField(Field(descriptionToMerge))
            } else {
                // hint:2F684DAC
                setDescription(descriptionToMerge)
            }
        }
    }

    // hint:87B3E19C
    fun setDescription(description: String?): Schema {
        return setDescriptionField(Field(description))
    }

    // hint:D465F782
    fun unsetDescription(): Schema {
        return setDescriptionField(Field.unset())
    }

    // hint:47C9A0F6
    fun addDescription(description: String): Schema {
        if (this.description != null) {
            throw IllegalStateException("Field description of Entity Schema is already set to '${this.description}', refused to add new value '$description'")
        }
        return setDescription(description)
    }

    ///////////////////////
    //
    // format
    //
    ///////////////////////

    // hint:3A7F9B2E
    val format: String?
        get() = _format.orNull

    // hint:F0C48D71
    fun setFormatField(format: Field<String?>): Schema {
        return copy(_format = format)
    }

    // hint:8E56A4D9
    fun updateFormatField(updater: (Field<String?>) -> Field<String?>): Schema {
        return setFormatField(updater(_format))
    }

    // hint:B1D730FC
    fun updateFormat(updater: (String?) -> String?): Schema {
        return updateFormatField { field ->
            field.flatMap { value ->
                Field(updater(value))
            }
        }
    }

    // hint:6542E98A
    fun mergeFormatField(formatFieldToMerge: Field<String?>): Schema {
        return mergeFormat(formatFieldToMerge.orNull)
    }

    // hint:A8BC6F23
    fun mergeFormat(formatToMerge: String?): Schema {
        return if (formatToMerge == null) {
            this
        } else {
            val oldFormat = _format.orNull
            if (oldFormat == null) {
                setFormatField(Field(formatToMerge))
            } else {
                // hint:2F684DAC
                setFormat(formatToMerge)
            }
        }
    }

    // hint:87B3E19C
    fun setFormat(format: String?): Schema {
        return setFormatField(Field(format))
    }

    // hint:D465F782
    fun unsetFormat(): Schema {
        return setFormatField(Field.unset())
    }

    // hint:47C9A0F6
    fun addFormat(format: String): Schema {
        if (this.format != null) {
            throw IllegalStateException("Field format of Entity Schema is already set to '${this.format}', refused to add new value '$format'")
        }
        return setFormat(format)
    }

    // hint:F1547C23
    fun setFormatUuid(): Schema {
        return setFormat("uuid")
    }

    // hint:8B64D9F0
    fun addFormatUuid(): Schema {
        return addFormat("uuid")
    }

    // hint:F1547C23
    fun setFormatInt32(): Schema {
        return setFormat("int32")
    }

    // hint:8B64D9F0
    fun addFormatInt32(): Schema {
        return addFormat("int32")
    }

    // hint:F1547C23
    fun setFormatInt64(): Schema {
        return setFormat("int64")
    }

    // hint:8B64D9F0
    fun addFormatInt64(): Schema {
        return addFormat("int64")
    }

    ///////////////////////
    //
    // default
    //
    ///////////////////////

    // hint:3A7F9B2E
    val default: DefaultJson?
        get() = _default.orNull

    // hint:F0C48D71
    fun setDefaultField(default: Field<DefaultJson?>): Schema {
        return copy(_default = default)
    }

    // hint:8E56A4D9
    fun updateDefaultField(updater: (Field<DefaultJson?>) -> Field<DefaultJson?>): Schema {
        return setDefaultField(updater(_default))
    }

    // hint:B1D730FC
    fun updateDefault(updater: (DefaultJson?) -> DefaultJson?): Schema {
        return updateDefaultField { field ->
            field.flatMap { value ->
                Field(updater(value))
            }
        }
    }

    // hint:6542E98A
    fun mergeDefaultField(defaultFieldToMerge: Field<DefaultJson?>): Schema {
        return mergeDefault(defaultFieldToMerge.orNull)
    }

    // hint:A8BC6F23
    fun mergeDefault(defaultToMerge: DefaultJson?): Schema {
        return if (defaultToMerge == null) {
            this
        } else {
            val oldDefault = _default.orNull
            if (oldDefault == null) {
                setDefaultField(Field(defaultToMerge))
            } else {
                // hint:E91B4F65
                setDefault(oldDefault.mergeEntity(defaultToMerge))
            }
        }
    }

    // hint:87B3E19C
    fun setDefault(default: DefaultJson?): Schema {
        return setDefaultField(Field(default))
    }

    // hint:D465F782
    fun unsetDefault(): Schema {
        return setDefaultField(Field.unset())
    }

    // hint:47C9A0F6
    fun addDefault(default: DefaultJson): Schema {
        if (this.default != null) {
            throw IllegalStateException("Field default of Entity Schema is already set to '${this.default}', refused to add new value '$default'")
        }
        return setDefault(default)
    }

    ///////////////////////
    //
    // nullable
    //
    ///////////////////////

    // hint:3A7F9B2E
    val nullable: Boolean
        get() = _nullable.orNull ?: false

    // hint:F0C48D71
    fun setNullableField(nullable: Field<Boolean>): Schema {
        return copy(_nullable = nullable)
    }

    // hint:8E56A4D9
    fun updateNullableField(updater: (Field<Boolean>) -> Field<Boolean>): Schema {
        return setNullableField(updater(_nullable))
    }

    // hint:B1D730FC
    fun updateNullable(updater: (Boolean) -> Boolean): Schema {
        return updateNullableField { field ->
            field.flatMap { value ->
                Field(updater(value))
            }
        }
    }

    // hint:6542E98A
    fun mergeNullableField(nullableFieldToMerge: Field<Boolean>): Schema {
        return mergeNullable(nullableFieldToMerge.orNull)
    }

    // hint:A8BC6F23
    fun mergeNullable(nullableToMerge: Boolean?): Schema {
        return if (nullableToMerge == null) {
            this
        } else {
            val oldNullable = _nullable.orNull
            if (oldNullable == null) {
                setNullableField(Field(nullableToMerge))
            } else {
                // hint:2F684DAC
                setNullable(nullableToMerge)
            }
        }
    }

    // hint:87B3E19C
    fun setNullable(nullable: Boolean): Schema {
        return setNullableField(Field(nullable))
    }

    // hint:D465F782
    fun unsetNullable(): Schema {
        return setNullableField(Field.unset())
    }

    // hint:47C9A0F6
    fun addNullable(nullable: Boolean = true): Schema {
        return setNullable(nullable)
    }

    ///////////////////////
    //
    // discriminator
    //
    ///////////////////////

    // hint:3A7F9B2E
    val discriminator: Discriminator?
        get() = _discriminator.orNull

    // hint:F0C48D71
    fun setDiscriminatorField(discriminator: Field<Discriminator?>): Schema {
        return copy(_discriminator = discriminator)
    }

    // hint:8E56A4D9
    fun updateDiscriminatorField(updater: (Field<Discriminator?>) -> Field<Discriminator?>): Schema {
        return setDiscriminatorField(updater(_discriminator))
    }

    // hint:B1D730FC
    fun updateDiscriminator(updater: (Discriminator?) -> Discriminator?): Schema {
        return updateDiscriminatorField { field ->
            field.flatMap { value ->
                Field(updater(value))
            }
        }
    }

    // hint:6542E98A
    fun mergeDiscriminatorField(discriminatorFieldToMerge: Field<Discriminator?>): Schema {
        return mergeDiscriminator(discriminatorFieldToMerge.orNull)
    }

    // hint:A8BC6F23
    fun mergeDiscriminator(discriminatorToMerge: Discriminator?): Schema {
        return if (discriminatorToMerge == null) {
            this
        } else {
            val oldDiscriminator = _discriminator.orNull
            if (oldDiscriminator == null) {
                setDiscriminatorField(Field(discriminatorToMerge))
            } else {
                // hint:E91B4F65
                setDiscriminator(oldDiscriminator.mergeEntity(discriminatorToMerge))
            }
        }
    }

    // hint:87B3E19C
    fun setDiscriminator(discriminator: Discriminator?): Schema {
        return setDiscriminatorField(Field(discriminator))
    }

    // hint:D465F782
    fun unsetDiscriminator(): Schema {
        return setDiscriminatorField(Field.unset())
    }

    // hint:47C9A0F6
    fun addDiscriminator(discriminator: Discriminator): Schema {
        if (this.discriminator != null) {
            throw IllegalStateException("Field discriminator of Entity Schema is already set to '${this.discriminator}', refused to add new value '$discriminator'")
        }
        return setDiscriminator(discriminator)
    }

    ///////////////////////
    //
    // readOnly
    //
    ///////////////////////

    // hint:3A7F9B2E
    val readOnly: Boolean
        get() = _readOnly.orNull ?: false

    // hint:F0C48D71
    fun setReadOnlyField(readOnly: Field<Boolean>): Schema {
        return copy(_readOnly = readOnly)
    }

    // hint:8E56A4D9
    fun updateReadOnlyField(updater: (Field<Boolean>) -> Field<Boolean>): Schema {
        return setReadOnlyField(updater(_readOnly))
    }

    // hint:B1D730FC
    fun updateReadOnly(updater: (Boolean) -> Boolean): Schema {
        return updateReadOnlyField { field ->
            field.flatMap { value ->
                Field(updater(value))
            }
        }
    }

    // hint:6542E98A
    fun mergeReadOnlyField(readOnlyFieldToMerge: Field<Boolean>): Schema {
        return mergeReadOnly(readOnlyFieldToMerge.orNull)
    }

    // hint:A8BC6F23
    fun mergeReadOnly(readOnlyToMerge: Boolean?): Schema {
        return if (readOnlyToMerge == null) {
            this
        } else {
            val oldReadOnly = _readOnly.orNull
            if (oldReadOnly == null) {
                setReadOnlyField(Field(readOnlyToMerge))
            } else {
                // hint:2F684DAC
                setReadOnly(readOnlyToMerge)
            }
        }
    }

    // hint:87B3E19C
    fun setReadOnly(readOnly: Boolean): Schema {
        return setReadOnlyField(Field(readOnly))
    }

    // hint:D465F782
    fun unsetReadOnly(): Schema {
        return setReadOnlyField(Field.unset())
    }

    // hint:47C9A0F6
    fun addReadOnly(readOnly: Boolean = true): Schema {
        return setReadOnly(readOnly)
    }

    ///////////////////////
    //
    // writeOnly
    //
    ///////////////////////

    // hint:3A7F9B2E
    val writeOnly: Boolean
        get() = _writeOnly.orNull ?: false

    // hint:F0C48D71
    fun setWriteOnlyField(writeOnly: Field<Boolean>): Schema {
        return copy(_writeOnly = writeOnly)
    }

    // hint:8E56A4D9
    fun updateWriteOnlyField(updater: (Field<Boolean>) -> Field<Boolean>): Schema {
        return setWriteOnlyField(updater(_writeOnly))
    }

    // hint:B1D730FC
    fun updateWriteOnly(updater: (Boolean) -> Boolean): Schema {
        return updateWriteOnlyField { field ->
            field.flatMap { value ->
                Field(updater(value))
            }
        }
    }

    // hint:6542E98A
    fun mergeWriteOnlyField(writeOnlyFieldToMerge: Field<Boolean>): Schema {
        return mergeWriteOnly(writeOnlyFieldToMerge.orNull)
    }

    // hint:A8BC6F23
    fun mergeWriteOnly(writeOnlyToMerge: Boolean?): Schema {
        return if (writeOnlyToMerge == null) {
            this
        } else {
            val oldWriteOnly = _writeOnly.orNull
            if (oldWriteOnly == null) {
                setWriteOnlyField(Field(writeOnlyToMerge))
            } else {
                // hint:2F684DAC
                setWriteOnly(writeOnlyToMerge)
            }
        }
    }

    // hint:87B3E19C
    fun setWriteOnly(writeOnly: Boolean): Schema {
        return setWriteOnlyField(Field(writeOnly))
    }

    // hint:D465F782
    fun unsetWriteOnly(): Schema {
        return setWriteOnlyField(Field.unset())
    }

    // hint:47C9A0F6
    fun addWriteOnly(writeOnly: Boolean = true): Schema {
        return setWriteOnly(writeOnly)
    }

    ///////////////////////
    //
    // example
    //
    ///////////////////////

    // hint:3A7F9B2E
    val example: ExampleJson?
        get() = _example.orNull

    // hint:F0C48D71
    fun setExampleField(example: Field<ExampleJson?>): Schema {
        return copy(_example = example)
    }

    // hint:8E56A4D9
    fun updateExampleField(updater: (Field<ExampleJson?>) -> Field<ExampleJson?>): Schema {
        return setExampleField(updater(_example))
    }

    // hint:B1D730FC
    fun updateExample(updater: (ExampleJson?) -> ExampleJson?): Schema {
        return updateExampleField { field ->
            field.flatMap { value ->
                Field(updater(value))
            }
        }
    }

    // hint:6542E98A
    fun mergeExampleField(exampleFieldToMerge: Field<ExampleJson?>): Schema {
        return mergeExample(exampleFieldToMerge.orNull)
    }

    // hint:A8BC6F23
    fun mergeExample(exampleToMerge: ExampleJson?): Schema {
        return if (exampleToMerge == null) {
            this
        } else {
            val oldExample = _example.orNull
            if (oldExample == null) {
                setExampleField(Field(exampleToMerge))
            } else {
                // hint:E91B4F65
                setExample(oldExample.mergeEntity(exampleToMerge))
            }
        }
    }

    // hint:87B3E19C
    fun setExample(example: ExampleJson?): Schema {
        return setExampleField(Field(example))
    }

    // hint:D465F782
    fun unsetExample(): Schema {
        return setExampleField(Field.unset())
    }

    // hint:47C9A0F6
    fun addExample(example: ExampleJson): Schema {
        if (this.example != null) {
            throw IllegalStateException("Field example of Entity Schema is already set to '${this.example}', refused to add new value '$example'")
        }
        return setExample(example)
    }

    ///////////////////////
    //
    // externalDocs
    //
    ///////////////////////

    // hint:3A7F9B2E
    val externalDocs: ExternalDocumentation?
        get() = _externalDocs.orNull

    // hint:F0C48D71
    fun setExternalDocsField(externalDocs: Field<ExternalDocumentation?>): Schema {
        return copy(_externalDocs = externalDocs)
    }

    // hint:8E56A4D9
    fun updateExternalDocsField(updater: (Field<ExternalDocumentation?>) -> Field<ExternalDocumentation?>): Schema {
        return setExternalDocsField(updater(_externalDocs))
    }

    // hint:B1D730FC
    fun updateExternalDocs(updater: (ExternalDocumentation?) -> ExternalDocumentation?): Schema {
        return updateExternalDocsField { field ->
            field.flatMap { value ->
                Field(updater(value))
            }
        }
    }

    // hint:6542E98A
    fun mergeExternalDocsField(externalDocsFieldToMerge: Field<ExternalDocumentation?>): Schema {
        return mergeExternalDocs(externalDocsFieldToMerge.orNull)
    }

    // hint:A8BC6F23
    fun mergeExternalDocs(externalDocsToMerge: ExternalDocumentation?): Schema {
        return if (externalDocsToMerge == null) {
            this
        } else {
            val oldExternalDocs = _externalDocs.orNull
            if (oldExternalDocs == null) {
                setExternalDocsField(Field(externalDocsToMerge))
            } else {
                // hint:E91B4F65
                setExternalDocs(oldExternalDocs.mergeEntity(externalDocsToMerge))
            }
        }
    }

    // hint:87B3E19C
    fun setExternalDocs(externalDocs: ExternalDocumentation?): Schema {
        return setExternalDocsField(Field(externalDocs))
    }

    // hint:D465F782
    fun unsetExternalDocs(): Schema {
        return setExternalDocsField(Field.unset())
    }

    // hint:47C9A0F6
    fun addExternalDocs(externalDocs: ExternalDocumentation): Schema {
        if (this.externalDocs != null) {
            throw IllegalStateException("Field externalDocs of Entity Schema is already set to '${this.externalDocs}', refused to add new value '$externalDocs'")
        }
        return setExternalDocs(externalDocs)
    }

    ///////////////////////
    //
    // deprecated
    //
    ///////////////////////

    // hint:3A7F9B2E
    val deprecated: Boolean
        get() = _deprecated.orNull ?: false

    // hint:F0C48D71
    fun setDeprecatedField(deprecated: Field<Boolean>): Schema {
        return copy(_deprecated = deprecated)
    }

    // hint:8E56A4D9
    fun updateDeprecatedField(updater: (Field<Boolean>) -> Field<Boolean>): Schema {
        return setDeprecatedField(updater(_deprecated))
    }

    // hint:B1D730FC
    fun updateDeprecated(updater: (Boolean) -> Boolean): Schema {
        return updateDeprecatedField { field ->
            field.flatMap { value ->
                Field(updater(value))
            }
        }
    }

    // hint:6542E98A
    fun mergeDeprecatedField(deprecatedFieldToMerge: Field<Boolean>): Schema {
        return mergeDeprecated(deprecatedFieldToMerge.orNull)
    }

    // hint:A8BC6F23
    fun mergeDeprecated(deprecatedToMerge: Boolean?): Schema {
        return if (deprecatedToMerge == null) {
            this
        } else {
            val oldDeprecated = _deprecated.orNull
            if (oldDeprecated == null) {
                setDeprecatedField(Field(deprecatedToMerge))
            } else {
                // hint:2F684DAC
                setDeprecated(deprecatedToMerge)
            }
        }
    }

    // hint:87B3E19C
    fun setDeprecated(deprecated: Boolean): Schema {
        return setDeprecatedField(Field(deprecated))
    }

    // hint:D465F782
    fun unsetDeprecated(): Schema {
        return setDeprecatedField(Field.unset())
    }

    // hint:47C9A0F6
    fun addDeprecated(deprecated: Boolean = true): Schema {
        return setDeprecated(deprecated)
    }

    ///////////////////////
    //
    // xml
    //
    ///////////////////////

    // hint:3A7F9B2E
    val xml: XML?
        get() = _xml.orNull

    // hint:F0C48D71
    fun setXmlField(xml: Field<XML?>): Schema {
        return copy(_xml = xml)
    }

    // hint:8E56A4D9
    fun updateXmlField(updater: (Field<XML?>) -> Field<XML?>): Schema {
        return setXmlField(updater(_xml))
    }

    // hint:B1D730FC
    fun updateXml(updater: (XML?) -> XML?): Schema {
        return updateXmlField { field ->
            field.flatMap { value ->
                Field(updater(value))
            }
        }
    }

    // hint:6542E98A
    fun mergeXmlField(xmlFieldToMerge: Field<XML?>): Schema {
        return mergeXml(xmlFieldToMerge.orNull)
    }

    // hint:A8BC6F23
    fun mergeXml(xmlToMerge: XML?): Schema {
        return if (xmlToMerge == null) {
            this
        } else {
            val oldXml = _xml.orNull
            if (oldXml == null) {
                setXmlField(Field(xmlToMerge))
            } else {
                // hint:E91B4F65
                setXml(oldXml.mergeEntity(xmlToMerge))
            }
        }
    }

    // hint:87B3E19C
    fun setXml(xml: XML?): Schema {
        return setXmlField(Field(xml))
    }

    // hint:D465F782
    fun unsetXml(): Schema {
        return setXmlField(Field.unset())
    }

    // hint:47C9A0F6
    fun addXml(xml: XML): Schema {
        if (this.xml != null) {
            throw IllegalStateException("Field xml of Entity Schema is already set to '${this.xml}', refused to add new value '$xml'")
        }
        return setXml(xml)
    }

    ///////////////////////
    //
    // extensions
    //
    ///////////////////////

    // hint:3A7F9B2E
    val extensions: Map<String, Extension?>
        get() = _extensions.orNull ?: emptyMap()

    // hint:F0C48D71
    fun setExtensionsField(extensions: Field<Map<String, Extension?>>): Schema {
        return copy(_extensions = extensions)
    }

    // hint:8E56A4D9
    fun updateExtensionsField(updater: (Field<Map<String, Extension?>>) -> Field<Map<String, Extension?>>): Schema {
        return setExtensionsField(updater(_extensions))
    }

    // hint:B1D730FC
    fun updateExtensions(updater: (Map<String, Extension?>) -> Map<String, Extension?>): Schema {
        return updateExtensionsField { field ->
            field.flatMap { value ->
                Field(updater(value))
            }
        }
    }

    // hint:6542E98A
    fun mergeExtensionsField(extensionsFieldToMerge: Field<Map<String, Extension?>>): Schema {
        return mergeExtensions(extensionsFieldToMerge.orNull)
    }

    // hint:A8BC6F23
    fun mergeExtensions(extensionsToMerge: Map<String, Extension?>?): Schema {
        return if (extensionsToMerge == null) {
            this
        } else {
            val oldExtensions = _extensions.orNull
            if (oldExtensions == null) {
                setExtensionsField(Field(extensionsToMerge))
            } else {
                // hint:70A3D8B6
                setExtensions(de.lancom.openapi.tools.mergeMap(oldExtensions, extensionsToMerge))
            }
        }
    }

    // hint:87B3E19C
    fun setExtensions(extensions: Map<String, Extension?>): Schema {
        return setExtensionsField(Field(extensions))
    }

    // hint:D465F782
    fun unsetExtensions(): Schema {
        return setExtensionsField(Field.unset())
    }

    // hint:5C81D396
    fun addExtensions(extensions: Map<String, Extension?>): Schema {
        return mergeExtensions(extensions)
    }

    // hint:1A6B37F8
    fun addExtensions(vararg extensions: Pair<String, Extension?>): Schema {
        return addExtensions(extensions.toMap())
    }

    // hint:9D0E4CA5
    fun addExtension(key: String, value: Extension?): Schema {
        return addExtensions(key to value)
    }

    // hint:B8F25E73
    fun addExtension(pair: Pair<String, Extension?>): Schema {
        return addExtensions(mapOf(pair))
    }

    // hint:6A81E3FD
    override val entityDescriptor: EntityDescriptor by lazy {
        EntityDescriptor(
            entity = this,
            jsonNode = null,
            map = mapOf(
                "title" to _title,
                "multipleOf" to _multipleOf,
                "maximum" to _maximum,
                "exclusiveMaximum" to _exclusiveMaximum,
                "minimum" to _minimum,
                "exclusiveMinimum" to _exclusiveMinimum,
                "maxLength" to _maxLength,
                "minLength" to _minLength,
                "pattern" to _pattern,
                "maxItems" to _maxItems,
                "minItems" to _minItems,
                "uniqueItems" to _uniqueItems,
                "maxProperties" to _maxProperties,
                "minProperties" to _minProperties,
                "required" to _required,
                "enum" to _enum,
                "type" to _type,
                "not" to _not,
                "allOf" to _allOf,
                "oneOf" to _oneOf,
                "anyOf" to _anyOf,
                "items" to _items,
                "properties" to _properties,
                "additionalProperties" to _additionalProperties,
                "description" to _description,
                "format" to _format,
                "default" to _default,
                "nullable" to _nullable,
                "discriminator" to _discriminator,
                "readOnly" to _readOnly,
                "writeOnly" to _writeOnly,
                "example" to _example,
                "externalDocs" to _externalDocs,
                "deprecated" to _deprecated,
                "xml" to _xml,
            ),
            flatMap = listOf(
                _extensions,
            ),
            flatten = listOf(
            ),
        )
    }

    override fun toString(): String {
        return this.toYamlString()
    }

    // hint:A0E5F382
    override fun mergeEntity(other: Entity?): Schema {
        return when (other) {
            null ->
                this

            is Schema ->
                merge(other)

            else ->
                TODO()
        }
    }

    // hint:716BFD54
    fun merge(other: Schema?): Schema {
        if (other == null) return this
        return this
            .mergeTitleField(other._title)
            .mergeMultipleOfField(other._multipleOf)
            .mergeMaximumField(other._maximum)
            .mergeExclusiveMaximumField(other._exclusiveMaximum)
            .mergeMinimumField(other._minimum)
            .mergeExclusiveMinimumField(other._exclusiveMinimum)
            .mergeMaxLengthField(other._maxLength)
            .mergeMinLengthField(other._minLength)
            .mergePatternField(other._pattern)
            .mergeMaxItemsField(other._maxItems)
            .mergeMinItemsField(other._minItems)
            .mergeUniqueItemsField(other._uniqueItems)
            .mergeMaxPropertiesField(other._maxProperties)
            .mergeMinPropertiesField(other._minProperties)
            .mergeRequiredField(other._required)
            .mergeEnumField(other._enum)
            .mergeTypeField(other._type)
            .mergeNotField(other._not)
            .mergeAllOfField(other._allOf)
            .mergeOneOfField(other._oneOf)
            .mergeAnyOfField(other._anyOf)
            .mergeItemsField(other._items)
            .mergePropertiesField(other._properties)
            .mergeAdditionalPropertiesField(other._additionalProperties)
            .mergeDescriptionField(other._description)
            .mergeFormatField(other._format)
            .mergeDefaultField(other._default)
            .mergeNullableField(other._nullable)
            .mergeDiscriminatorField(other._discriminator)
            .mergeReadOnlyField(other._readOnly)
            .mergeWriteOnlyField(other._writeOnly)
            .mergeExampleField(other._example)
            .mergeExternalDocsField(other._externalDocs)
            .mergeDeprecatedField(other._deprecated)
            .mergeXmlField(other._xml)
            .mergeExtensionsField(other._extensions)
    }

    companion object : ReferenceParser<Schema> {

        class Serializer : EntitySerializer<Schema>(Schema::class.java, Schema)
        class Deserializer : EntityDeserializer<Schema>(Schema::class.java, Schema)

        // hint:5F72B6D8
        override fun parseWrapper(wrapper: Wrapper): Schema {
            return de.lancom.openapi.jackson.extensionParser(wrapper, ::parseWrapperWithExtensions)
        }

        // hint:2C0E94A7
        fun parseWrapperWithExtensions(wrapper: Wrapper, extensions: Field<Map<String, Extension?>>): Schema {
            return Schema(
                _title = wrapper["title"].getNullOrElse {
                    getSingle {
                        getSingle {
                            getString()
                        }
                    }
                },
                _multipleOf = wrapper["multipleOf"].getNullOrElse {
                    getSingle {
                        getSingle {
                            getInt()
                        }
                    }
                },
                _maximum = wrapper["maximum"].getNullOrElse {
                    getSingle {
                        getSingle {
                            getInt()
                        }
                    }
                },
                _exclusiveMaximum = wrapper["exclusiveMaximum"].getSingle {
                    getSingle {
                        getSingle {
                            getBoolean()
                        }
                    }
                },
                _minimum = wrapper["minimum"].getNullOrElse {
                    getSingle {
                        getSingle {
                            getInt()
                        }
                    }
                },
                _exclusiveMinimum = wrapper["exclusiveMinimum"].getSingle {
                    getSingle {
                        getSingle {
                            getBoolean()
                        }
                    }
                },
                _maxLength = wrapper["maxLength"].getNullOrElse {
                    getSingle {
                        getSingle {
                            getInt()
                        }
                    }
                },
                _minLength = wrapper["minLength"].getSingle {
                    getSingle {
                        getSingle {
                            getInt()
                        }
                    }
                },
                _pattern = wrapper["pattern"].getNullOrElse {
                    getSingle {
                        getSingle {
                            getString()
                        }
                    }
                },
                _maxItems = wrapper["maxItems"].getNullOrElse {
                    getSingle {
                        getSingle {
                            getInt()
                        }
                    }
                },
                _minItems = wrapper["minItems"].getSingle {
                    getSingle {
                        getSingle {
                            getInt()
                        }
                    }
                },
                _uniqueItems = wrapper["uniqueItems"].getSingle {
                    getSingle {
                        getSingle {
                            getBoolean()
                        }
                    }
                },
                _maxProperties = wrapper["maxProperties"].getNullOrElse {
                    getSingle {
                        getSingle {
                            getInt()
                        }
                    }
                },
                _minProperties = wrapper["minProperties"].getSingle {
                    getSingle {
                        getSingle {
                            getInt()
                        }
                    }
                },
                _required = wrapper["required"].getNullOrElse {
                    getSet {
                        getNullOrElse {
                            getString()
                        }
                    }
                },
                _enum = wrapper["enum"].getNullOrElse {
                    getSet {
                        getNullOrElse {
                            getString()
                        }
                    }
                },
                _type = wrapper["type"].getNullOrElse {
                    getSingle {
                        getSingle {
                            getEnum(SchemaType::valueOf)
                        }
                    }
                },
                _not = wrapper["not"].getNullOrElse {
                    getSingle {
                        getSingle {
                            getSingle(Schema::parseReferenceOrEntityOpt)
                        }
                    }
                },
                _allOf = wrapper["allOf"].getNullOrElse {
                    getList {
                        getNullOrElse {
                            getSingle(Schema::parseReferenceOrEntityOpt)
                        }
                    }
                },
                _oneOf = wrapper["oneOf"].getNullOrElse {
                    getList {
                        getNullOrElse {
                            getSingle(Schema::parseReferenceOrEntityOpt)
                        }
                    }
                },
                _anyOf = wrapper["anyOf"].getNullOrElse {
                    getList {
                        getNullOrElse {
                            getSingle(Schema::parseReferenceOrEntityOpt)
                        }
                    }
                },
                _items = wrapper["items"].getNullOrElse {
                    getSingle {
                        getSingle {
                            getSingle(Schema::parseReferenceOrEntityOpt)
                        }
                    }
                },
                _properties = wrapper["properties"].getNullOrElse {
                    getMap {
                        getNullOrElse {
                            getSingle(Schema::parseReferenceOrEntityOpt)
                        }
                    }
                },
                _additionalProperties = wrapper["additionalProperties"].getSingle {
                    getSingle {
                        getSingle {
                            getSingle(AdditionalProperties::parseEntity)
                        }
                    }
                },
                _description = wrapper["description"].getNullOrElse {
                    getSingle {
                        getSingle {
                            getString()
                        }
                    }
                },
                _format = wrapper["format"].getNullOrElse {
                    getSingle {
                        getSingle {
                            getString()
                        }
                    }
                },
                _default = wrapper["default"].getNullOrElse {
                    getSingle {
                        getSingle {
                            getSingle(DefaultJson::parseEntityOpt)
                        }
                    }
                },
                _nullable = wrapper["nullable"].getSingle {
                    getSingle {
                        getSingle {
                            getBoolean()
                        }
                    }
                },
                _discriminator = wrapper["discriminator"].getNullOrElse {
                    getSingle {
                        getSingle {
                            getSingle(Discriminator::parseEntityOpt)
                        }
                    }
                },
                _readOnly = wrapper["readOnly"].getSingle {
                    getSingle {
                        getSingle {
                            getBoolean()
                        }
                    }
                },
                _writeOnly = wrapper["writeOnly"].getSingle {
                    getSingle {
                        getSingle {
                            getBoolean()
                        }
                    }
                },
                _example = wrapper["example"].getNullOrElse {
                    getSingle {
                        getSingle {
                            getSingle(ExampleJson::parseEntityOpt)
                        }
                    }
                },
                _externalDocs = wrapper["externalDocs"].getNullOrElse {
                    getSingle {
                        getSingle {
                            getSingle(ExternalDocumentation::parseEntityOpt)
                        }
                    }
                },
                _deprecated = wrapper["deprecated"].getSingle {
                    getSingle {
                        getSingle {
                            getBoolean()
                        }
                    }
                },
                _xml = wrapper["xml"].getNullOrElse {
                    getSingle {
                        getSingle {
                            getSingle(XML::parseEntityOpt)
                        }
                    }
                },
                _extensions = extensions,
            )
        }
    }
}
